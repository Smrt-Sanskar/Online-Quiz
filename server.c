// Server.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <netinet/in.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <sys/socket.h>
#include <linux/in.h>
#define MAXREQ 1000
#define MAXQUEUE 1000

typedef struct
{
  int sock;
  struct sockaddr address;
  int addr_len;
  char name[12];
} connection_t;

int str_cmp(char* str1, char* str2, int n1, int n2) {
  if ((strlen(str1) < n1) || (strlen(str2) < n2) || (n1 != n2))
    return 0;
  else {
    for (int i = 0; i < n1; i++) {
      if (str1[i] != str2[i])
        return 0;
    }
  }
  return 1;
}

// HardCoded Questions
char *ques_text_1[1000] = {"Consider three processes (process id 0, 1, 2 respectively) with compute time bursts 2, 4 and 8 time units. All processes arrive at time zero. Consider the longest remaining time first (LRTF) scheduling algorithm. In LRTF ties are broken by giving priority to the process with the lowest process id. The average turn around time is:\n(A) 13 units\n(B) 14 units\n(C) 15 units\n(D) 16 units\n",
                           "#include<stdio.h>\n#include<unistd.h>\nint main()\n{if (fork() && fork())\n{fork();\nfork();\nfork();\nfork();\n.\n.\n.\nn times.\n}\n}\n(A)2^n +1\n(B)2^n+2\n(C)2^n +3\n(D)1\n",
                           "Consider 4 processes p1,p2,p3,p4 , their arrival time is same and 0th second. now their brust times are 53,17,68,24 seconds respectively. consider scheduling process to be multilevel feedback queue scheduling. there are 3 queues q1,q2,q3  and their priority order is (1>2>3).q1,q2 follows round-robin process of scheduling with quantum 17 and 25 respectively for q1 and q2. q3 follows fcfs mechanism. tell us which process is completed at last.\n(A)p1\n(B)p2\n(C)p3\n(D)p4\n"
                          };

char *ans_1[1000] = {"A\n", "C\n", "C\n"};

char *expln_1[1000] = {"The gnatt chart is shown\n p2  p1  p2  p1  p2  p0  p1   p2   p0   p1   p2\n0   4   5   6   7   8   9   10    11   12   13   14 \n", "lets talk about first  fork in 'if' , here 1 child process is created c1, now as child is 0 ( 0 && anyhting=0) so, the process stops here without entering into if statement. if parent is called for 1st fork inside if then we go to second fork , now a new child process is created c2. if child is called here, the process stops. if parent is called then it enters inside if statement, here new 2^n child will be created . so total count c1,c2,2^n childs , 1 parent. hence 2^n+3 is correct answer.\n",
                       "gnatt chart is given below:\np1 p2  p3  p4  p1  p3  p4     p1     p3\n0 17  34  51  68  93  118  125   136     162\n"
                      };

char *ques_text_2[1000] = {"A process can be ___\n(A) single threaded\n(B) multithreaded\n(C) both single threaded and multithreaded\n(D) none of the mentioned\n",
                           "Which module gives control of the CPU to the process selected by the short-term scheduler?\n(A) dispatcher\n(B) interrupt\n(C) scheduler\n(D) none of the mentioned\n",
                           "The interval from the time of submission of a process to the time of completion is termed as ____________\n(A) waiting time\n(B) turnaround time\n(C) response time\n(D) throughput\n"
                          };

char *ans_2[1000] = {"C\n", "A\n", "B\n"};

char *expln_2[1000] = {"A process can be both multithreaded and single threaded.\n", "dispatcher gives the control of the CPU to the process selected by the short-term scheduler.\n",
                       "The interval from the time of submission of a process to the time of completion is termed as turn around time.\n"
                      };

char *ques_text_3[1000] = {"Increasing the RAM of a computer typically improves performance because:\n(A) Virtual memory increases\n(B) Larger RAMs are faster\n(C) Fewer page faults occur\n(D) Fewer segmentation faults occur\n",
                           "A memory buffer used to accommodate a speed differential is called ____________\n(A) stack pointer\n(B) cache\n(C) accumulator\n(D) disk buffer\n",
                           "Which one of the following is the address generated by CPU?\n(A) physical address\n(B) absolute address\n(C) logical address\n(D) none of the mentioned\n"
                          };

char *ans_3[1000] = {"C\n", "B\n", "C\n"};

char *expln_3[1000] = {"Explanation: When there is more RAM, there would be more mapped virtual pages in physical memory, hence fewer page faults. A page fault causes performance degradation as the page has to be loaded from secondary device.\n", "cache is used to accommodate a speed differential\n", "logical address is the address generated by CPU\n"};
int cnt1 = 3, cnt2 = 3, cnt3 = 3;

char mm[100] = "Memory Management:", th[100] = "Threads:", sch[100] = "Scheduling:";
char expn[100] = "Explanation:", answ[100] = "Answer:", lbreak[100] = "\n\n";

/*void server(int consockfd) {
  char reqbuf[MAXREQ];
  int n;
  while (1) {
    memset(reqbuf, 0, MAXREQ);
    n = read(consockfd, reqbuf, MAXREQ - 1); // Recv
    //printf("Recvd msg:%s\n", reqbuf);
    if (n <= 0) return 0;
    n = write(consockfd, reqbuf, strlen(reqbuf)); // echo
  }
}*/

void * server(void * ptr) {

  char reqbuf[MAXREQ];
  int n;
  int len;
  connection_t * conn;
  long addr = 0;
  if (!ptr) pthread_exit(0);
  conn = (connection_t *)ptr;
  int consockfd = conn->sock;
  memset(reqbuf, 0, MAXREQ);
  n = read(consockfd, reqbuf, MAXREQ - 1);
  if (n <= 0) {
    close(conn->sock);
    free(conn);
    pthread_exit(0);
    return 0;
  }
  while (1) {
    for (int i = 5; i < 17; i++) {
      if (reqbuf[i] != '\0' && reqbuf[i] != '\n') conn->name[i - 5] = reqbuf[i];
      else conn->name[i - 5] = ' ';
    }
    char reply[1000] = "Welcome ############ to Online Quiz on OS.\nSelect Mode:\n\t-press I for individual mode\n\t-press G for group mode\n\t-press A for admin mode\n";
    for (int i = 8; i < 20; i++) reply[i] = conn->name[i - 8];
    n = write(consockfd, reply, strlen(reply));

    memset(reqbuf, 0, MAXREQ);
    n = read(consockfd, reqbuf, MAXREQ - 1);
    if (n <= 0) {
      close(conn->sock);
      free(conn);
      pthread_exit(0);
      return 0;
    }
    if (reqbuf[0] == 'I') {
      char reply[1000] = "OK. Pick a topic from the following:\n\t1.Threads\n\t2.Scheduling\n\t3.Memory management\n";
      n = write(consockfd, reply, strlen(reply));

      memset(reqbuf, 0, MAXREQ);
      n = read(consockfd, reqbuf, MAXREQ - 1);
      if (n <= 0) {
        close(conn->sock);
        free(conn);
        pthread_exit(0);
        return 0;
      }
      if (reqbuf[0] == '1') { // Threads
        while (1) {
          int l = 0;
          int r = cnt1 - 1;
          int x = (rand() % (r - l + 1)) + l;
          n = write(consockfd, ques_text_1[x], strlen(ques_text_1[x]));

          memset(reqbuf, 0, MAXREQ);
          n = read(consockfd, reqbuf, MAXREQ - 1);
          if (n <= 0) {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }
          char prompt[1000] = "-press 'n' to attempt another question\n-press 'q' to quit\n-press 'r' to return to main menu.\n";
          if (reqbuf[0] == ans_1[x][0]) {
            char reply[1000] = "Correct. The explanation is below:\n";
            int len = strlen(reply), i = 0;

            for (i = 0; i < strlen(expln_1[x]); i++) {
              reply[i + len] = expln_1[x][i];
            }

            len = strlen(reply), i = 0;

            for (i = 0; i < strlen(prompt); i++) {
              reply[i + len] = prompt[i];
            }
            reply[i + len] = '\0';
            reply[i + len + 1] = '\n';
            n = write(consockfd, reply, strlen(reply));
          }
          else {
            char reply[1000] = "Wrong. The explanation is below:\n";
            int len = strlen(reply), i = 0;

            for (i = 0; i < strlen(expln_1[x]); i++) {
              reply[i + len] = expln_1[x][i];
            }

            len = strlen(reply), i = 0;

            for (i = 0; i < strlen(prompt); i++) {
              reply[i + len] = prompt[i];
            }
            reply[i + len] = '\0';
            reply[i + len + 1] = '\n';
            n = write(consockfd, reply, strlen(reply));
          }

          memset(reqbuf, 0, MAXREQ);
          n = read(consockfd, reqbuf, MAXREQ - 1);
          if (n <= 0) {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }
          if (reqbuf[0] == 'n') ;
          else if (reqbuf[0] == 'q') {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }
          else break;
        }
      }
      else if (reqbuf[0] == '2') { //Scheduling
        while (1) {
          int l = 0;
          int r = cnt2 - 1;
          int x = (rand() % (r - l + 1)) + l;
          n = write(consockfd, ques_text_2[x], strlen(ques_text_2[x]));

          memset(reqbuf, 0, MAXREQ);
          n = read(consockfd, reqbuf, MAXREQ - 1);
          if (n <= 0) {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }

          char prompt[1000] = "-press 'n' to attempt another question\n-press 'q' to quit\n-press 'r' to return to main menu.\n";
          if (reqbuf[0] == ans_2[x][0]) {
            char reply[1000] = "Correct. The explanation is below:\n";
            int len = strlen(reply), i = 0;

            for (i = 0; i < strlen(expln_2[x]); i++) {
              reply[i + len] = expln_2[x][i];
            }

            len = strlen(reply), i = 0;

            for (i = 0; i < strlen(prompt); i++) {
              reply[i + len] = prompt[i];
            }
            reply[i + len] = '\0';
            reply[i + len + 1] = '\n';
            n = write(consockfd, reply, strlen(reply));
          }
          else {
            char reply[1000] = "Wrong. The explanation is below:\n";
            int len = strlen(reply), i = 0;

            for (i = 0; i < strlen(expln_2[x]); i++) {
              reply[i + len] = expln_2[x][i];
            }

            len = strlen(reply), i = 0;

            for (i = 0; i < strlen(prompt); i++) {
              reply[i + len] = prompt[i];
            }
            reply[i + len] = '\0';
            reply[i + len + 1] = '\n';
            n = write(consockfd, reply, strlen(reply));
          }

          memset(reqbuf, 0, MAXREQ);
          n = read(consockfd, reqbuf, MAXREQ - 1);
          if (n <= 0) {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }

          if (reqbuf[0] == 'n') ;
          else if (reqbuf[0] == 'q') {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }
          else break;
        }
      }
      else {  // Memory Management
        while (1) {
          int l = 0;
          int r = cnt3 - 1;
          int x = (rand() % (r - l + 1)) + l;
          n = write(consockfd, ques_text_3[x], strlen(ques_text_3[x]));

          memset(reqbuf, 0, MAXREQ);
          n = read(consockfd, reqbuf, MAXREQ - 1);
          if (n <= 0) return 0;
          char prompt[1000] = "-press 'n' to attempt another question\n-press 'q' to quit\n-press 'r' to return to main menu.\n";
          if (reqbuf[0] == ans_3[x][0]) {
            char reply[1000] = "Correct. The explanation is below:\n";
            int len = strlen(reply), i = 0;

            for (i = 0; i < strlen(expln_3[x]); i++) {
              reply[i + len] = expln_3[x][i];
            }

            len = strlen(reply), i = 0;

            for (i = 0; i < strlen(prompt); i++) {
              reply[i + len] = prompt[i];
            }
            reply[i + len] = '\0';
            n = write(consockfd, reply, strlen(reply));
          }
          else {
            char reply[1000] = "Wrong. The explanation is below:\n";
            int len = strlen(reply), i = 0;

            for (i = 0; i < strlen(expln_3[x]); i++) {
              reply[i + len] = expln_3[x][i];
            }

            len = strlen(reply), i = 0;

            for (i = 0; i < strlen(prompt); i++) {
              reply[i + len] = prompt[i];
            }
            reply[i + len] = '\0';
            n = write(consockfd, reply, strlen(reply));
          }

          memset(reqbuf, 0, MAXREQ);
          n = read(consockfd, reqbuf, MAXREQ - 1);
          if (n <= 0) {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }
          if (reqbuf[0] == 'n') ;
          else if (reqbuf[0] == 'q') {
            close(conn->sock);
            free(conn);
            pthread_exit(0);
            return 0;
          }
          else break;
        }
      }
    }
    else if (reqbuf[0] == 'G') {
      ; // GROUP MODE
    }
    else {
      char reply[1000] = "Reading questions from file questions.txt\n-press 'q' to quit\n-press 'r' to return to main menu.\n";
      n = write(consockfd, reply, strlen(reply));

      // Reading from file questions.txt
      FILE *f = fopen("questions.txt", "rb");
      fseek(f, 0, SEEK_END);
      long fsize = ftell(f);
      fseek(f, 0, SEEK_SET);

      char *string = malloc(fsize + 1);
      fread(string, 1, fsize, f);
      fclose(f);

      string[fsize] = 0;

      while (strlen(string)) {
        if (str_cmp(string, mm, strlen(mm), strlen(mm))) {
          string += strlen(mm); //Memory Management:

          static char ques1[1000];
          int idx_mq = 0;
          while (1 - str_cmp(string, answ, strlen(answ), strlen(answ))) {
            ques1[idx_mq++] = string[0];
            string++;
          }
          ques1[idx_mq] = '\0';
          string += strlen(answ); //Answer:

          static char answer1[1000];
          int idx_ma = 0;
          while (1 - str_cmp(string, expn, strlen(expn), strlen(expn))) {
            answer1[idx_ma++] = string[0];
            string++;
          }
          answer1[idx_ma] = '\0';
          string += strlen(expn); //Explanation:

          static char expln1[1000];
          int idx_me = 0;
          while (1 - str_cmp(string, lbreak, strlen(lbreak), strlen(lbreak))) {
            expln1[idx_me++] = string[0];
            string++;
          }
          expln1[idx_me] = '\0';
          string += strlen(lbreak); //Explanation:

          // ADD Everything to corresponding arrays
          // Putting into corresponding arrays
          ques_text_3[cnt1] = ques1;
          ans_3[cnt1] = answer1;
          expln_3[cnt1] = expln1;
          cnt1++;
        }
        else if (str_cmp(string, th, strlen(th), strlen(th))) { // Threads
          string += strlen(th); //Threads:

          static char ques2[1000];
          int idx_tq = 0;
          while (1 - str_cmp(string, answ, strlen(answ), strlen(answ))) {
            ques2[idx_tq++] = string[0];
            string++;
          }
          ques2[idx_tq] = '\0';
          string += strlen(answ); //Answer:

          static char answer2[1000];
          int idx_ta = 0;
          while (1 - str_cmp(string, expn, strlen(expn), strlen(expn))) {
            answer2[idx_ta++] = string[0];
            string++;
          }
          answer2[idx_ta] = '\0';
          string += strlen(expn); //Explanation:

          static char expln2[1000];
          int idx_te = 0;
          while (1 - str_cmp(string, lbreak, strlen(lbreak), strlen(lbreak))) {
            expln2[idx_te++] = string[0];
            string++;
          }
          //printf("%s\n",expln);
          expln2[idx_te] = '\0';
          string += strlen(lbreak); //Explanation:

          // Putting into corresponding arrays
          ques_text_1[cnt2] = ques2;
          ans_1[cnt2] = answer2;
          expln_1[cnt2] = expln2;
          cnt2++;
        } else if (str_cmp(string, sch, strlen(sch), strlen(sch))) {
          string += strlen(sch); //Scheduling:

          static char ques3[1000];
          int idx_sq = 0;
          while (1 - str_cmp(string, answ, strlen(answ), strlen(answ))) {
            ques3[idx_sq++] = string[0];
            string++;
          }
          ques3[idx_sq] = '\0';
          string += strlen(answ); //Answer:

          static char answer3[1000];
          int idx_sa = 0;
          while (1 - str_cmp(string, expn, strlen(expn), strlen(expn))) {
            answer3[idx_sa++] = string[0];
            string++;
          }
          answer3[idx_sa] = '\0';
          string += strlen(expn); //Explanation:

          static char expln3[1000];
          int idx_se = 0;
          while (1 - str_cmp(string, lbreak, strlen(lbreak), strlen(lbreak))) {
            expln3[idx_se++] = string[0];
            string++;
          }
          expln3[idx_se] = '\0';
          string += strlen(lbreak); //Explanation:

          // Putting into corresponding arrays
          ques_text_2[cnt3] = ques3;
          ans_2[cnt3] = answer3;
          expln_2[cnt3] = expln3;
          cnt3++;
        }

      }

      memset(reqbuf, 0, MAXREQ);
      n = read(consockfd, reqbuf, MAXREQ - 1);
      if (n <= 0) {
        close(conn->sock);
        free(conn);
        pthread_exit(0);
        return 0;
      }
      if (reqbuf[0] == 'n') ;
      else if (reqbuf[0] == 'q') {
        close(conn->sock);
        free(conn);
        pthread_exit(0);
        return 0;
      }
      else;
    }
  }
  close(conn->sock);
  free(conn);
  pthread_exit(0);
  return 0;
}


int main() {

  int lstnsockfd, consockfd, clilen, portno = 5033;
  struct sockaddr_in serv_addr, cli_addr;

  connection_t * connection;
  pthread_t thread;

  memset((char *) &serv_addr, 0, sizeof(serv_addr));
  serv_addr.sin_family      = AF_INET;
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  serv_addr.sin_port        = htons(portno);

// Server protocol
  /* Create Socket to receive requests*/
  lstnsockfd = socket(AF_INET, SOCK_STREAM, 0);

  /* Bind socket to port */
  bind(lstnsockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
  printf("Bounded to port\n");

  /* Listen for incoming connections */
  listen(lstnsockfd, MAXQUEUE);

  while (1) {
    printf("Listening for incoming connections\n");

    connection = (connection_t *)malloc(sizeof(connection_t));
    //clilen = sizeof(cl_addr);

    /* Accept incoming connection, obtaining a new socket for it */
    connection->sock = accept(lstnsockfd, &connection->address,
                              &connection->addr_len);
    printf("Accepted connection\n");

    if (consockfd <= 0) {
      free(connection);
    }
    else {
      pthread_create(&thread, 0, server, (void *)connection);
      pthread_detach(thread);
    }
  }
  close(lstnsockfd);
}
